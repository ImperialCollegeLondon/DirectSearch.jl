var documenterSearchIndex = {"docs":
[{"location":"man/addpoll/#Adding-a-Poll-Step-1","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"","category":"section"},{"location":"man/addpoll/#Implementation-1","page":"Adding a Poll Step","title":"Implementation","text":"","category":"section"},{"location":"man/addpoll/#","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"A poll step can be implemented in a very similar manner to a search step. However, a poll stage should return a direction, not a discrete point. Therefore the function GenerateDirections should be overridden instead. As with the search step, this takes the problem as the first argument and the poll type as the second, and returns a vector of directions. A struct configuring a poll type must inherit the AbstractPoll type. As an example, please see the file src/LTMADS.jl.","category":"page"},{"location":"man/addpoll/#","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"Note that, for the convergence properties of MADS to hold, the poll step has several requirements, and therefore it is generally recommended to use LTMADS or OrthoMADS and modify the search stage to fit the problem.","category":"page"},{"location":"man/addpoll/#Organisation-1","page":"Adding a Poll Step","title":"Organisation","text":"","category":"section"},{"location":"man/addpoll/#","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"Custom poll stages should be included in their own file.","category":"page"},{"location":"ref/public/#Public-API-1","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"These functions and types implement the API of DirectSearch.jl. ","category":"page"},{"location":"ref/public/#Problem-Configuration-1","page":"Public API","title":"Problem Configuration","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"DSProblem\nSetObjective\nSetInitialPoint\nOptimize!\nSetIterationLimit\nSetVariableRange\nSetVariableRanges\nBumpIterationLimit\nProblemSense\nSetMaxEvals","category":"page"},{"location":"ref/public/#DirectSearch.DSProblem","page":"Public API","title":"DirectSearch.DSProblem","text":"DSProblem{T}(N::Int; poll::AbstractPoll=LTMADS{T}(), \n                     search::AbstractSearch=NullSearch(),\n                     objective::Union{Function,Nothing}=nothing,\n                     initial_point::Vector{T}=zeros(T, N),\n                     iteration_limit::Int=1000,\n                     sense::ProblemSense=Min)\n\nReturn a problem definition for an N dimensional problem.\n\npoll and search specify the poll and search step algorithms to use. The default choices are (LTMADS)[@ref] and (NullSearch)[@ref] respectively.\n\nNote that if working with Float64 (normally the case) then the type parameterisation can be ignored.\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#DirectSearch.SetObjective","page":"Public API","title":"DirectSearch.SetObjective","text":"SetObjective(p::DSProblem, obj::Function)\n\nSets the target objective function to solve. obj should take a vector and return a single cost value.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetInitialPoint","page":"Public API","title":"DirectSearch.SetInitialPoint","text":"SetInitialPoint(p::DSProblem{T}, x::Vector{T}) where T\n\nSet the initial incumbent point to x. This must be of the correct dimension. If using  any extreme barrier constraints then it must also satisfy these constraints.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.Optimize!","page":"Public API","title":"DirectSearch.Optimize!","text":"Optimize!(p::DSProblem)\n\nRun the direct search algorithm on problem p.\n\np must have had its initial point and objective function set. If extreme  barrier constraints have been set then the initial point must be value for  those constraints.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetIterationLimit","page":"Public API","title":"DirectSearch.SetIterationLimit","text":"SetIterationLimit(p::DSProblem, i::Int)\n\nSet the maximum number of iterations to i.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetVariableRange","page":"Public API","title":"DirectSearch.SetVariableRange","text":"SetVariableRange(p::DSProblem{T}, index::Int, l::T, u::T) where T\n\nSet the expected range of the variable with index i to between lower (l) and upper (u) values. This does not create a constraint, and is only used for scaling when a variable varies with a significantly different scale to the others.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetVariableRanges","page":"Public API","title":"DirectSearch.SetVariableRanges","text":"SetVariableRanges(p::DSProblem{T}, l::Vector{T}, u::Vector{T}) where T\n\nCall SetVariableRange for each variable. The vectors l and u should contain a lower and upper bound for each variable. If it is desired to keep a variable at default scaling, then give it upper and lower bounds of -5 and 5 respectively.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.BumpIterationLimit","page":"Public API","title":"DirectSearch.BumpIterationLimit","text":"BumpIterationLimit(p::DSProblem, val::Int=100)\n\nIncrease the iteration limit by i.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetMaxEvals","page":"Public API","title":"DirectSearch.SetMaxEvals","text":"SetMaxEvals(p::DSProblem, m::Int)\n\nSet the maximum number of simultaneous function evaluations that can be run. By default this will be set 1.\n\nIf (DirectSearch.function_evaluation)[@ref] is not overriden (e.g. for sending  calculation to a cluster) then setting this to a number greater than your PC's  number of threads will result in no improvement.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#Search-Stages-1","page":"Public API","title":"Search Stages","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"NullSearch\nRandomSearch","category":"page"},{"location":"ref/public/#DirectSearch.NullSearch","page":"Public API","title":"DirectSearch.NullSearch","text":"NullSearch()\n\nReturn no trial points for a search stage (ie, skips the search stage from running)\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#DirectSearch.RandomSearch","page":"Public API","title":"DirectSearch.RandomSearch","text":"RandomSearch(M::Int)\n\nReturn M randomly chosen trial points from the current mesh.\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#Poll-Stages-1","page":"Public API","title":"Poll Stages","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"LTMADS\nOrthoMADS","category":"page"},{"location":"ref/public/#DirectSearch.LTMADS","page":"Public API","title":"DirectSearch.LTMADS","text":"LTMADS()\n\nReturn an empty LTMADS object. \n\nLTMADS is a poll stage that creates a set of directions based on a semi-randomly generated lower triangular matrix. This randomness means that several runs of the algorithm may be needed to find a minimum.\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#DirectSearch.OrthoMADS","page":"Public API","title":"DirectSearch.OrthoMADS","text":"OrthoMADS(N::Int)\n\nReturn an empty OrthoMADS object. N must match the dimension of the problem that this stage is being given to.\n\nOrthoMADS uses Halton sequences to generate an orthogonal basis of directiosn for the poll step. This is a deterministic process, unlike (LTMADS)[@ref].\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#Constraints-1","page":"Public API","title":"Constraints","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"AddExtremeConstraint(p::DirectSearch.AbstractProblem, f::Function)\nAddExtremeConstraint(p::DirectSearch.AbstractProblem, f::Vector{Function})\nAddProgressiveConstraint(p::DirectSearch.AbstractProblem, f::Function)\nAddProgressiveConstraint(p::DirectSearch.AbstractProblem, f::Vector{Function})\nAddExtremeCollection(p::DirectSearch.AbstractProblem)\nAddProgressiveCollection(p::DirectSearch.AbstractProblem)\nDefaultExtremeRef\nDefaultProgressiveRef","category":"page"},{"location":"ref/public/#DirectSearch.AddExtremeConstraint-Tuple{DirectSearch.AbstractProblem,Function}","page":"Public API","title":"DirectSearch.AddExtremeConstraint","text":"AddExtremeConstraint(p::AbstractProblem, c::Function\n                     index::CollectionIndex=CollectionIndex(1)\n                    )::ConstraintIndex where T\n\nRegister a single function that defines an extreme barrier constraint. Return a constraint index.\n\nThe provided function should take a vector input and return a boolean or numeric value indicating if the constraint has been met or not. true or less than or  equal to 0 indicates the constraint has been met. false or greater than 0 shows the constraint has been violated.\n\nThe index argument can be specified to give a collection to add the constraint  to. The specified collection must exist, and must be able to accept extreme  barrier constraints. If index is not specified then it is added to collection  1, the default extreme constraint collection.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddExtremeConstraint-Tuple{DirectSearch.AbstractProblem,Array{Function,1}}","page":"Public API","title":"DirectSearch.AddExtremeConstraint","text":"AddExtremeConstraint(p::AbstractProblem, c::Vector{Function}; index::CollectionIndex=CollectionIndex(1))\n\nRegister a group of functions that define extreme barrier constraints. Calls  AddExtremeConstraint on each function individually.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddProgressiveConstraint-Tuple{DirectSearch.AbstractProblem,Function}","page":"Public API","title":"DirectSearch.AddProgressiveConstraint","text":"AddProgressiveConstraint(p::AbstractProblem, c::Function; index::CollectionIndex=CollectionIndex(2))\n\nRegister a single function that defines a progressive barrier constraint. Return an index that refers to the constraint.\n\nThe provided function should take a vector input and return a numeric value  indicating if the constraint has been met or not. Less than or  equal to 0 indicates the constraint has been met. 0 shows the constraint has  been violated.\n\nThe index argument can be specified to give a collection to add the constraint  to. The specified collection must exist, and must be able to accept progressive  barrier constraints. If index is not specified then it is added to collection  2, the default progressive barrier constraint collection.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddProgressiveConstraint-Tuple{DirectSearch.AbstractProblem,Array{Function,1}}","page":"Public API","title":"DirectSearch.AddProgressiveConstraint","text":"AddProgressiveConstraint(p::AbstractProblem, c::Vector{Function})::Vector{Int}\n\nRegister a group of functions that define progressive barrier constraints. Calls  AddProgressiveConstraint on each function individually.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddExtremeCollection-Tuple{DirectSearch.AbstractProblem}","page":"Public API","title":"DirectSearch.AddExtremeCollection","text":"AddExtremeCollection(p::Constraints{T})::CollectionIndex where T\n\nInstantiate a new constraint collection for extreme constraints. Returns an index that  refers to the new collection.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddProgressiveCollection-Tuple{DirectSearch.AbstractProblem}","page":"Public API","title":"DirectSearch.AddProgressiveCollection","text":"AddProgressiveCollection(p::Constraints{T}; h_max=Inf, h_max_update::Function=h_max_update, \n                         aggregator::Function=x->max(0,x)^2)::CollectionIndex where T\n\nInstantiate a new constraint collection within the problem. Returns an index that refers to this new collection.\n\nThe default constraint settings match those from Audet & Dennis 2009:\n\nh_max: Begins as infinity\n\nh_max_update: Sets h_max to the largest valid h evaluation if an iteration is improving\n\naggregator: Creates h as sum k(x) where k=max(0x)^2\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.DefaultExtremeRef","page":"Public API","title":"DirectSearch.DefaultExtremeRef","text":"DefaultExtremeRef\n\nThe collection index that refers to the default location of extreme barrier  constraints.\n\n\n\n\n\n","category":"constant"},{"location":"ref/public/#DirectSearch.DefaultProgressiveRef","page":"Public API","title":"DirectSearch.DefaultProgressiveRef","text":"DefaultProgressiveRef\n\nThe collection index that refers to the default location of progressive barrier  constraints.\n\n\n\n\n\n","category":"constant"},{"location":"ref/public/#Reporting-1","page":"Public API","title":"Reporting","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"Many functions in this section are out of date, do not rely on them to give accurate information","category":"page"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"DirectSearch.report_finish\nDirectSearch.report\nDirectSearch.export_points\nDirectSearch.ReportConstraints(::DSProblem)\nDirectSearch.ReportConstraintCollection","category":"page"},{"location":"ref/public/#DirectSearch.report_finish","page":"Public API","title":"DirectSearch.report_finish","text":"report_finish(p::DSProblem)\n\nNot Implemented\n\nIf not silent, give a short printout of the result of the problem.\n\nStates the duration, final point, final cost, and reason for stopping. A more detailed report can be shown with report.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.report","page":"Public API","title":"DirectSearch.report","text":"report(p::DSProblem; save::Union{Bool,String}=false)\n\nPrints a summary of the problem to the console, or saves it as a text file.\n\nsave=true saves the report in the current REPL directory, but will error  if the default file name report is taken. Otherwise give a path as an argument to use that name.\n\nThe report contains the solver configuration, the initial and final incumbent points, the initial and final cost, the duration, the number of iterations, and the current status.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.export_points","page":"Public API","title":"DirectSearch.export_points","text":"export_points(p::DSProblem)\n\nGives the trace of considered points during optimisation. Note that this is unavailable if tracking of points has been disabled \n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#Internal-API-1","page":"Internal","title":"Internal API","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"These functions and types are for internal usage and should generally not be accessed during normal use of the package. This will likely be useful if implementing an extension to the package. ","category":"page"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"Fully documenting every function is currently ongoing. Please raise an issue if information is missing.","category":"page"},{"location":"ref/internal/#Core-1","page":"Internal","title":"Core","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.OptimizationStatus\nDirectSearch.EvaluateInitialPoint\nDirectSearch.EvaluatePoint!\nDirectSearch.function_evaluation(::DSProblem{T}, ::Vector{Vector{T}}) where T\nDirectSearch.function_evaluation(::DSProblem{T}, ::Vector{T}) where T\nDirectSearch.MeshUpdate!(::DSProblem, ::DirectSearch.IterationOutcome)\nDirectSearch.GetMeshSize\nDirectSearch.min_mesh_size(::DSProblem{Float64})\nDirectSearch.min_mesh_size(::DSProblem{T}) where T\nDirectSearch.AbstractMesh\nDirectSearch.Mesh\nDirectSearch.AbstractProblem","category":"page"},{"location":"ref/internal/#DirectSearch.EvaluatePoint!","page":"Internal","title":"DirectSearch.EvaluatePoint!","text":"EvaluatePoint!(p::DSProblem{T}, trial_points)::IterationOutcome where T\n\nDetermine whether the set of trial points result in a dominating, improving, or unsuccesful algorithm iteration. Update the feasible and infeasible incumbent points of p.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.function_evaluation-Union{Tuple{T}, Tuple{DSProblem{T},Array{Array{T,1},1}}} where T","page":"Internal","title":"DirectSearch.function_evaluation","text":"function_evaluation(p::DSProblem{T}, trial_points::Vector{Vector{T}})::Vector{T} where T\n\nCalculate the cost of the points in trial_points and return as a vector. \n\nIf the number of available workers is greater than one, and the maxsimultaniousevaluations value of p is greater than one then the calculation is distributed across  several cores. \n\nCurrently, this has significant overheads and is much slower than evaluating in a single threaded manner on all testcases. This may give performance benefits when f is a heavy, single threaded operation.\n\nIf a specialised way  of calling the function is needed then this function should be overriden, e.g.: \n\nfunction DS.function_evaluation(p::DS.DSProblem{T}, trial_points::Vector{Vector{T}}) where T\n\tprintln(\"I am overriden\")\t\n\treturn map(p.objective, trial_points)\nend\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.function_evaluation-Union{Tuple{T}, Tuple{DSProblem{T},Array{T,1}}} where T","page":"Internal","title":"DirectSearch.function_evaluation","text":"function_evaluation(p::DSProblem{T}, trial_point::Vector{T})::T where T\n\nEvaluate a single trial point with the objective function of p. \n\nBy default calls the function with the trial point and returns the result. Override to  provide custom evaluation behaviour.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.AbstractMesh","page":"Internal","title":"DirectSearch.AbstractMesh","text":"abstract type AbstractMesh end\n\nParent type of any struct implementing the construction of a mesh. To maintain  compatibility with other aspects of the package, the naming convention for  variables within structs must be followed. These respect the notation used  within Audet & Dennis 2006.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#Constraints-1","page":"Internal","title":"Constraints","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.AbstractConstraint\nDirectSearch.IterationOutcome\nDirectSearch.ConstraintOutcome\nDirectSearch.CollectionIndex\nDirectSearch.ConstraintIndex\nDirectSearch.ConstraintCollection\nDirectSearch.h_max_update\nDirectSearch.AbstractProgressiveConstraint\nDirectSearch.ProgressiveConstraint\nDirectSearch.ExtremeConstraint\nDirectSearch.Constraints\nDirectSearch.CollectionTypeCount\nDirectSearch.ConstraintUpdate!\nDirectSearch.ConstraintEvaluation\nDirectSearch.GetHmaxSum\nDirectSearch.ConstraintCollectionEvaluation(::DirectSearch.ConstraintCollection{T,DirectSearch.ProgressiveConstraint}, ::Vector{T}) where T\nDirectSearch.ConstraintCollectionEvaluation(::DirectSearch.ConstraintCollection{T,DirectSearch.ExtremeConstraint}, ::Vector{T}) where T","category":"page"},{"location":"ref/internal/#DirectSearch.IterationOutcome","page":"Internal","title":"DirectSearch.IterationOutcome","text":"@enum IterationOutcome\n\nHas values Dominating, Improving, or Unsuccessful. Corresponding to the three  iteration outcomes in MADS-PB.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ConstraintOutcome","page":"Internal","title":"DirectSearch.ConstraintOutcome","text":"@enum ConstraintOutcome\n\nHas the values Feasible, WeakInfeasible, or StrongInfeasible to classify  the outcome of the constraint evaluations of a single point. \n\nA Feasible point meets the requirement of all constraints with no relaxation. \n\nA WeakInfeasible outcome has at least one relaxable constraint violated  but no unrelaxable constraints violated.\n\nA StrongInfeasible outcome indicates at least one unrelaxable constraint has been violated or the relaxable constraint violation is reater than hmax.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.CollectionIndex","page":"Internal","title":"DirectSearch.CollectionIndex","text":"CollectionIndex\n\nAn Int wrapper that is used for indexing constraint collections within a  Constraints object.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ConstraintIndex","page":"Internal","title":"DirectSearch.ConstraintIndex","text":"CollectionIndex\n\nAn Int wrapper that is used for indexing constraints within a  ConstraintCollection object.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ConstraintCollection","page":"Internal","title":"DirectSearch.ConstraintCollection","text":"ConstraintCollection{T,C}(h_max::T, \n                          h_max_update::Function, \n                          aggregator::Function\n                         ) where {T,C<:AbstractConstraint}\n\nContains multiple constraints of the same type that have the same settings  applied to them.\n\nh_max is the initial hmax value.  h_max_update is a function that should update h_max given an  IterationOutcome value.  aggregator is a function that will bring all constraint violations of a  collection into a single h result.\n\nDefaults for each of these values are set in the AddProgressiveCollection and  AddExtremeCollection functions.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.AbstractProgressiveConstraint","page":"Internal","title":"DirectSearch.AbstractProgressiveConstraint","text":"AbstractProgressiveConstraint <: AbstractConstraint\n\nParent type for progressive contraints.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ProgressiveConstraint","page":"Internal","title":"DirectSearch.ProgressiveConstraint","text":"ProgressiveConstraint(f::Function)\n\nCreate a progressive barrier constraint. \n\nArgument f is a function that should take a single vector argument and  return a value that gives the amount the constraint function has been  violated. \n\nA value greater than 0 indicates the function has been violated, 0 shows that the input lies on the constraint, and negative numbers show a feasible value. \n\nNegative numbers may be truncated to 0 without affecting the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ExtremeConstraint","page":"Internal","title":"DirectSearch.ExtremeConstraint","text":"ExtremeConstraint(f::Function)\n\nCreate an extreme barrier constraint. Function f should take a vector argument  and return true or false to indicate if the vector meets the constraint.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.Constraints","page":"Internal","title":"DirectSearch.Constraints","text":"Constraints{T}() where T\n\nCreate an object that constains multiple ConstraintCollection objects and their corresponding ConstraintCache.\n\nUpon creation Constraints is automaticvally populated with two constraint  collections, an ExtremeCollection and a ProgressiveCollection.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.CollectionTypeCount","page":"Internal","title":"DirectSearch.CollectionTypeCount","text":"CollectionTypeCount(c::Constraints{T}, C::AbstractConstraint)::Int where T\n\nReturn the total number of constraints of type C that are stored in all collections.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.ConstraintEvaluation","page":"Internal","title":"DirectSearch.ConstraintEvaluation","text":"ConstraintEvaluation(constraints::Constraints{T}, p::Vector{T})::Tuple{ConstraintOutcome,T} where T\n\nEvaluate point p over all constraint collections in constraints. Returns a  ConstraintOutcome indicating the result of the evaluation:\n\nFeasible: p evaluated as feasible for all constraints (extreme and progressive barrier)\n\nWeakInfeasible: p evaluated as feasible for all extreme barrier constraints, and had no  progressive barrier constraint violations greater than h_max\n\nStrongInfeasible: At least one extreme barrier constraint evaluated as infeasible, or at least one progressive barrier constraint had a violation greater than h_max\n\nThe second returned value is the sum of h_max values evaluated during the constraint checks.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.ConstraintCollectionEvaluation-Union{Tuple{T}, Tuple{DirectSearch.ConstraintCollection{T,DirectSearch.ProgressiveConstraint},Array{T,1}}} where T","page":"Internal","title":"DirectSearch.ConstraintCollectionEvaluation","text":"ConstraintCollectionEvaluation(collection::ConstraintCollection{T,ProgressiveConstraint}, \n                               x::Vector{T})::ConstraintOutcome where T\n\nEvalute every constraint within progressive constraint collection collection  for point x.\n\nIf the aggregate value of the constraint evaluations exceeds the collection's  h_max then a StrongInfeasible is returned. If the value is less than or equal to 0.0 then Feasible is returned. Otherwise WeakInfeasible is returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.ConstraintCollectionEvaluation-Union{Tuple{T}, Tuple{DirectSearch.ConstraintCollection{T,DirectSearch.ExtremeConstraint},Array{T,1}}} where T","page":"Internal","title":"DirectSearch.ConstraintCollectionEvaluation","text":"ConstraintCollectionEvaluation(collection::ConstraintCollection{T,ExtremeConstraint}, \n                               x::Vector{T})::ConstraintOutcome where T\n\nEvalute every constraint within extreme constraint collection collection for  point x.\n\nIf any constraint returns false  or a value greater than 0 then a  StrongInfeasible result is returned. Otherwise a Feasible result is returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#Poll-1","page":"Internal","title":"Poll","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.Poll\nDirectSearch.AbstractPoll\nDirectSearch.GeneratePollPoints\nDirectSearch.GenerateDirections(::DSProblem)","category":"page"},{"location":"ref/internal/#DirectSearch.Poll","page":"Internal","title":"DirectSearch.Poll","text":"Poll(p::DSProblem{T})::IterationOutcome where T\n\nGenerate points and call evaluate on them.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.AbstractPoll","page":"Internal","title":"DirectSearch.AbstractPoll","text":"abstract type AbstractPollDirectionGenerator end\n\nParent type for any type used for implementing a direction generator.\n\nGenerally any direction generators should return vectors with unit length of one\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.GeneratePollPoints","page":"Internal","title":"DirectSearch.GeneratePollPoints","text":"GeneratePollPoints(p::DSProblem{T}, ::AbstractMesh)::Vector{Vector{T}} where T\n\nGenerate a set of directions with the configured polling algorithm, then return the set of points these directions give from the incumbent points.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.GenerateDirections-Tuple{DSProblem}","page":"Internal","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::DSProblem{T}, DG::LTMADS{T})::Vector{Vector{T}}\n\nGenerates columns and forms a basis matrix for direction generation. \n\n\n\n\n\nGenerateDirections(p::DSProblem{T}, DG::LTMADS{T})::Vector{Vector{T}}\n\nGenerates columns and forms a basis matrix for direction generation. \n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#Search-1","page":"Internal","title":"Search","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.Search\nDirectSearch.AbstractSearch\nDirectSearch.GenerateSearchPoints(::DSProblem{T}) where T\nDirectSearch.GenerateSearchPoints(::DSProblem{T}, ::RandomSearch) where T\nDirectSearch.GenerateSearchPoints(::DSProblem, ::NullSearch)","category":"page"},{"location":"ref/internal/#DirectSearch.GenerateSearchPoints-Union{Tuple{DSProblem{T}}, Tuple{T}} where T","page":"Internal","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem{T})::Vector{Vector{T}} where T\n\nCalls GenerateSearchPoints for the search step within p.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.GenerateSearchPoints-Union{Tuple{T}, Tuple{DSProblem{T},RandomSearch}} where T","page":"Internal","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem{T}, ::RandomSearch)::Vector{Vector{T}} where T\n\nFinds points that are Δᵐ distance from any point in the mesh in a uniformly random direction.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.GenerateSearchPoints-Tuple{DSProblem,NullSearch}","page":"Internal","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem)\n\nSearch method that returns an empty vector.\n\nUse when no search method is desired.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#LTMADS-1","page":"Internal","title":"LTMADS","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.MeshUpdate!(::DirectSearch.Mesh, ::LTMADS, ::DirectSearch.IterationOutcome)\nDirectSearch.GenerateDirections(::DirectSearch.AbstractProblem, ::LTMADS{T}) where T\nDirectSearch.form_basis_matrix\nDirectSearch.LT_basis_generation\nDirectSearch.B′_generation\nDirectSearch.b_l_generation\nDirectSearch.L_generation\nDirectSearch.B_generation","category":"page"},{"location":"ref/internal/#DirectSearch.MeshUpdate!-Tuple{DirectSearch.Mesh,LTMADS,DirectSearch.IterationOutcome}","page":"Internal","title":"DirectSearch.MeshUpdate!","text":"MeshUpdate!(mesh::Mesh, improvement_found::Bool)\n\nImplements LTMADS update rule from Audet & Dennis 2006 pg. 203 adapted for progressive  barrier constraints with Audet & Dennis 2009 expression 2.4.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.GenerateDirections-Union{Tuple{T}, Tuple{DirectSearch.AbstractProblem,LTMADS{T}}} where T","page":"Internal","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::DSProblem{T}, DG::LTMADS{T})::Vector{Vector{T}}\n\nGenerates columns and forms a basis matrix for direction generation. \n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#OrthoMADS-1","page":"Internal","title":"OrthoMADS","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.MeshUpdate!(::DirectSearch.Mesh, ::OrthoMADS, ::DirectSearch.IterationOutcome)\nDirectSearch.GenerateDirections(::DirectSearch.AbstractProblem, ::OrthoMADS{T}) where T\nDirectSearch.GenerateDirections(::Int64, ::OrthoMADS)\nDirectSearch.GenerateOMBasis\nDirectSearch.Halton\nDirectSearch.HaltonEntry\nDirectSearch.HaltonCoefficient\nDirectSearch.AdjustedHalton\nDirectSearch.AdjustedHaltonFamily\nDirectSearch.bad_argmax\nDirectSearch.HouseholderTransform","category":"page"},{"location":"ref/internal/#DirectSearch.MeshUpdate!-Tuple{DirectSearch.Mesh,OrthoMADS,DirectSearch.IterationOutcome}","page":"Internal","title":"DirectSearch.MeshUpdate!","text":"MeshUpdate!(mesh::Mesh, o::OrthoMADS, result::IterationOutcome)\n\nImplements the OrthoMads update rules.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.GenerateDirections-Union{Tuple{T}, Tuple{DirectSearch.AbstractProblem,OrthoMADS{T,F} where F}} where T","page":"Internal","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::DSProblem{T}, DG::LTMADS{T})::Vector{Vector{T}}\n\nGenerates columns and forms a basis matrix for direction generation. \n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#Cache-1","page":"Internal","title":"Cache","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.AbstractCache\nDirectSearch.PointCache\nDirectSearch.CachePush(::DirectSearch.AbstractProblem{T}, ::Vector{T}, ::T) where T\nDirectSearch.CachePush(::DirectSearch.AbstractProblem)\nDirectSearch.CacheQuery(::DirectSearch.AbstractProblem, ::Vector)\nDirectSearch.CacheGet(::DirectSearch.AbstractProblem, ::Vector)\nDirectSearch.CacheRandomSample(::DirectSearch.AbstractProblem, ::Int)\nDirectSearch.CacheInitialPoint(::DirectSearch.AbstractProblem)\nDirectSearch.CacheGetRange(::DirectSearch.AbstractProblem, ::Vector)\nDirectSearch.CacheFilter(::DirectSearch.AbstractProblem, ::Vector)","category":"page"},{"location":"ref/internal/#DirectSearch.PointCache","page":"Internal","title":"DirectSearch.PointCache","text":"PointCache{T} <: AbstractCache\n\nAn abstract cache subtype that contains a dictionary of points/costs and a vector that stores the order of incumbent points.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.CachePush-Union{Tuple{T}, Tuple{DirectSearch.AbstractProblem{T},Array{T,1},T}} where T","page":"Internal","title":"DirectSearch.CachePush","text":"CachePush(p::AbstractProblem, x::Vector, cost)\n\nAdd point x and its cost cost to the cache of p. \n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CachePush-Tuple{DirectSearch.AbstractProblem}","page":"Internal","title":"DirectSearch.CachePush","text":"CachePush(p::AbstractProblem)\n\nAdd the feasible and infeasible incumbent points (assuming neither are nothing) to the cache.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheQuery-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Internal","title":"DirectSearch.CacheQuery","text":"CacheQuery(p::AbstractProblem, x::Vector)\n\nQuery the cache of p to find if it has a cost value for point x. Alias  to haskey.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheGet-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Internal","title":"DirectSearch.CacheGet","text":"CacheGet(p::AbstractProblem, x::Vector)\n\nReturn the cost of point x in the cache of p. Does not check if  x is in the cache, use CacheQuery to check.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheRandomSample-Tuple{DirectSearch.AbstractProblem,Int64}","page":"Internal","title":"DirectSearch.CacheRandomSample","text":"CacheRandomSample(p::AbstractProblem, n::Int)\n\nReturns a uniformly sampled collection of n points from the cache. Points  can be repeated in the sample.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheInitialPoint-Tuple{DirectSearch.AbstractProblem}","page":"Internal","title":"DirectSearch.CacheInitialPoint","text":"CacheInitialPoint(p::AbstractProblem)\n\nReturn a tuple of the initial point added to the cache and its cost.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheGetRange-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Internal","title":"DirectSearch.CacheGetRange","text":"CacheGetRange(p::AbstractProblem, points::Vector)::Vector{Vector}\n\nReturn a vector of costs corresponding to the vector of points.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheFilter-Tuple{DirectSearch.AbstractProblem,Array{T,1} where T}","page":"Internal","title":"DirectSearch.CacheFilter","text":"CacheFilter(p::AbstractProblem{T}, points::Vector{T})::Tuple{Vector{Vector{T}},Vector{Vector{T}}} where T\n\nReturn a tuple where the first entry is the set of input points in the cache and the second is the set of input points not in the cache.\n\n\n\n\n\n","category":"method"},{"location":"man/usage/#Usage-1","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"DirectSearch.jl provides a framework for the implementation of direct search algorithms, currently focusing on the Mesh Adaptive Direct Search (MADS) family. These are derivative free, black box algorithms, meaning that no analytical knowledge of the objective function or any constraints are needed. This package provides the core MADS algorithms (LTMADS, OrthoMADS, as well as progressive and extreme barrier constraints), and is designed to allow custom algorithms to be easily added.","category":"page"},{"location":"man/usage/#Problem-Specification-1","page":"Usage","title":"Problem Specification","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The core data structure is the DSProblem type. At a minimum it requires the dimension of the problem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(3);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The objective function, initial point, and other parameters may be specified in DSProblem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"obj(x) = x'*[2 1;1 4]*x + x'*[1;4] + 7;\np = DSProblem(2; objective=obj, initial_point=[1.0,2.0]);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Note that the objective function is assumed to take a vector of points of points as the input, and return a scalar cost. The initial point should be an array of the same dimensions of the problem, and feasible with respect to any extreme barrier constraints. See DSProblem's documentation for a full list of parameters.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Parameters can also be set after generation of the problem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(2)\nSetInitialPoint(p, [1.0,2.0])\nSetObjective(p,obj)\nSetIterationLimit(p, 500)","category":"page"},{"location":"man/usage/#Variable-Scaling-1","page":"Usage","title":"Variable Scaling","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The range of problem variables can be set with SetVariableRange or SetVariableRanges. This sets a scale factor that is applied to poll directions before calculating trial poll points. If all variables are of a similar scale and are of a magnitude reasonably close to 10 then the default scaling should be sufficient. ","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"If a single variable is of a very different order of magnitude, then it can be scaled with SetVariableRange. i is the index of the variable, and the following numbers are the upper and lower bound of the variable respectively.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetVariableRange(p, i, 10000, 20000)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The same operation can be applied to all indexes with SetVariableRanges (example for N=3):","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetVariableRanges(p, [10000, -5, -10000], [20000, 5, 10000])","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Be aware that this does not add a constraint on the variable, it only creates a scale factor that is applied to generated poll directions. Constraints on variable range should be added explicitly as constraints.","category":"page"},{"location":"man/usage/#Optimizing-1","page":"Usage","title":"Optimizing","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Run the algorithm with Optimize!.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Optimize!(p)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"This will run MADS until either the iteration limit (default 1000), or precision limit (Float64 precision) are reached. The reason for stopping can be accessed as the status variable within the problem.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"@show p.status\n> p.status = DirectSearch.PrecisionLimit","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The results can also be found in a similar manner:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"@show p.x\n> p.x = [0.0, -0.5]\n@show p.x_cost\n> p.x_cost = 6.0","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"(Functions for accessing this data will be added in future.)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"If optimization stopped due to reaching an iteration limit, then the limit can be quickly increased with the BumpIterationLimit function:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"BumpIterationLimit(p) #Increments iteration limit by 100 iterations\nBumpIterationLimit(p, n) #Increments iteration limit by n iterations","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"And then optimization can be resumed by calling optimize! again.","category":"page"},{"location":"man/usage/#Type-Parameterisation-1","page":"Usage","title":"Type Parameterisation","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"By default, DSProblem is parameterised as Float64, but this can be overridden:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem{Float32}(3);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"However, this is mostly untested and will almost certainly break. It is included to allow future customisation to be less painful.","category":"page"},{"location":"man/usage/#Constraints-1","page":"Usage","title":"Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Two kinds of constraints are included, progressive barrier, and extreme barrier constraints. As with the objective function, these should be specified as a Julia function that takes a vector, and returns a value. ","category":"page"},{"location":"man/usage/#Extreme-Barrier-Constraints-1","page":"Usage","title":"Extreme Barrier Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Extreme barrier constraints are constraints that cannot be violated, and their function should return boolean (true for a feasible point, false for infeasible), or a numerical value giving the constraint violation amount (≤0 for feasible, >0 for infeasible). Added with AddExtremeConstraint:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"cons(x) = x[1] > 0 #Constrains x[1] to be larger than 0\nAddExtremeConstraint(p, cons)","category":"page"},{"location":"man/usage/#Progressive-Barrier-Constraints-1","page":"Usage","title":"Progressive Barrier Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Progressive barrier constraints may be violated, transforming the optimization into a dual-objective form that attempts to decrease the amount that the constraint is violated by. Functions that implement a progressive barrier constraint should take a point input and return a numerical value that indicates the constraint violation amount (≤0 for feasible, >0 for infeasible). Added via AddProgressiveConstraint:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"cons(x) = x[1] #Constraints x[1] to be less than or equal to 0\nAddProgressiveConstraint(p, cons)","category":"page"},{"location":"man/usage/#Equality-Constraints-1","page":"Usage","title":"Equality Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The package does not care about the form of constraints (as they are treated like a black box). However in many cases, the algorithm will not be able to generate trial points that are exactly able to satisfy equality constraints. ","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Therefore, to implement extreme barrier equality constraints a tolerance should be included in the constraint function. Alternatively progressive barrier constraints can be used, but it is likely that the algorithm will not be able to generate feasible solutions, but the final point should be very close to feasible.","category":"page"},{"location":"man/usage/#Constraint-Indexes-1","page":"Usage","title":"Constraint Indexes","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The functions to add a constraint return an index that can be used to refer to the constraints for modification. When supplied with a vector of functions both constraint functions will return a vector of indexes.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Currently these indexes have no direct use. But functions to ignore constraints will be added in future.","category":"page"},{"location":"man/usage/#Collections-1","page":"Usage","title":"Collections","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Constraints are stored in data structures named 'Collections'. Each collection can contain any number of constraints of the same type. By default, extreme barrier constraints are stored in collection one, and progressive barrier constraints in collection two. In most cases, collections can be ignored.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"New collections can be created with the following functions:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"AddProgressiveCollection(p);\nAddExtremeCollection(p);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The collection contains configuration options for the constraints within it. For example, by default the progressive barrier collection uses a square norm when summing constraint violation, this can be configured to use an alternate norm by defining a new collection. See the documentation for the individual functions for all the possible configuration options.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"As with adding individual constraints, collections return an index. This is useful for specifying a collection to add a constraint to. These indexes will also be used to refer to the collections for modification in future. ","category":"page"},{"location":"man/usage/#Method-Choice-1","page":"Usage","title":"Method Choice","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"MADS defines two stages in each iteration: search and poll. ","category":"page"},{"location":"man/usage/#Search-1","page":"Usage","title":"Search","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The search stage employs an arbitrary strategy to look for an improved point in the current mesh. This can be designed to take advantage of a known property of the objective function's structure, or be something generic, for example, a random search, or ignored. ","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"A search step returns a set of points that are then evaluated on the objective function.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The choice of search strategy is set in DSProblem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(3; search=RandomSearch(10))","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The current included search strategies are NullSearch and RandomSearch. NullSearch will perform no search stage and is the default choice. RandomSearch will select M random points on the current mesh, where M is the option given to it when instantiated.","category":"page"},{"location":"man/usage/#Poll-1","page":"Usage","title":"Poll","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The poll step is a more rigorously defined exploration in the local space around the incumbent point.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Poll steps return a set of directions that are then evaluated with a preset distance value.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"As with the search step, it is set in DSProblem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(3; poll=LTMADS())\np = DSProblem(3; poll=OrthoMADS(3))","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Two poll steps are included. The first is LTMADS, which generates a set of directions from a basis generated from a semi-random lower triangular matrix. The other is OrthoMADS, a later algorithm that generates an orthogonal set of directions. OrthoMADS needs the dimension of the problem to be provided. By default, LTMADS is used.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Note that OrthoMADS is deterministic, therefore using DirectSearch with OrthoMADS will always give the same result (assuming the objective function and constraints are also deterministic). LTMADS has a random element, and will therefore give different results every time it is run. For this reason, LTMADS may need several runs to achieve its best result.","category":"page"},{"location":"man/usage/#Custom-Algorithms-1","page":"Usage","title":"Custom Algorithms","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"DirectSearch.jl is designed to make it simple to add custom search and poll stages. See Adding a Search Step and Adding a Poll Step for an overview of this.","category":"page"},{"location":"#DirectSearch.jl-1","page":"Home","title":"DirectSearch.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DirectSearch.jl implements several algorithms in the Mesh Adaptive Direct Search family and is designed to be easily modifiable but still high performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For details on the theory of the algorithms implemented here, please see:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"MADS (and LTMADS) : C.Audet and J.E. Dennis, \"Mesh adaptive direct search algorithms for constrained optimization,\" SIAM Journal on Optimization, vol. 17, no. 1, pp. 188-217, 2007\nProgressive Barrier MADS : C.Audet and J.E. Dennis, \"A progressive barrier for derivative-free nonlinear programming,\" SIAM Journal on Optimization, vol. 20, no. 1, pp. 445-472, 2009\nOrthoMADS : M. A. Abramson, C. Audet, J. E. Dennis, and S. Le Digabel, “Orthomads: A deterministic MADS instance with orthogonal directions,” SIAM Journal on Optimization, vol. 20, no. 2,pp. 948–966, 2009","category":"page"},{"location":"#Public-API-1","page":"Home","title":"Public API","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"ref/public.md\"]","category":"page"},{"location":"man/addsearch/#Adding-a-Search-Step-1","page":"Adding a Search Step","title":"Adding a Search Step","text":"","category":"section"},{"location":"man/addsearch/#Implementation-1","page":"Adding a Search Step","title":"Implementation","text":"","category":"section"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"Implementing a custom search strategy is relatively simple. It requires the implementation of a type that configures the step, and a corresponding function that implements it. The configuration type should inherit from AbstractSearch, and the function should be an implementation of the GenerateSearchPoints function that takes a DSProblem and your custom type as arguments, and returns a vector of vectors.","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"For example, a very simple random search around the current incumbent point could be defined with the struct:","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"struct RandomLocalSearch <: AbstractSearch\n    # Number of points to generate\n    N::Int \n    # Maximum distance to explore\n    d::Float64\nend","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"And then the corresponding implementation with a method of the function GenerateSearchPoints:","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"function GenerateSearchPoints(p::DSProblem{T}, s::RandomLocalSearch)::Vector{Vector{T}} where T\n    points = []\n    # Generating s.N points\n    for i in 1:s.N\n        # Generate offset vector\n        offset = zeros(p.N)\n        offset[rand(1:p.N)] = rand(-s.d:s.d)\n        # Append to points list\n        push!(points, p.x + offset)\n    end\n    # Return list\n    return points\nend","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"This can then be used as with any other search method:","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"p = DSProblem(3; poll=LTMADS(), search=RandomLocalSearch(5, 0.1));","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"(Note that this search method it is unlikely to give good results due to not adapting the direction variable d to the current mesh size.)","category":"page"},{"location":"man/addsearch/#Organisation-1","page":"Adding a Search Step","title":"Organisation","text":"","category":"section"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"Unless it is very simple (ie, fits within a single function) please implement your search method in its own file. This ensures that extra functions that are part of the method are kept in a relevant place. ","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"If a custom search method may be useful to other people, please consider contributing it back to the package.","category":"page"}]
}
