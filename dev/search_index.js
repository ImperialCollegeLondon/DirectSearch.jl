var documenterSearchIndex = {"docs":
[{"location":"man/cache/#Cache-1","page":"Cache","title":"Cache","text":"","category":"section"},{"location":"man/cache/#Cache-Saving-and-Loading-1","page":"Cache","title":"Cache Saving and Loading","text":"","category":"section"},{"location":"man/cache/#","page":"Cache","title":"Cache","text":"The evaluated costs during the optimization process are stored in the cache as a dictionary with the poll point as the key, and its evaluted cost as the value. The cache may be saved in a file after running the optimization, and can then be pre-loaded in order to reduce the number of function evaluations in a future run.","category":"page"},{"location":"man/cache/#","page":"Cache","title":"Cache","text":"Two formats are currently supported: JSON and JLD2.","category":"page"},{"location":"man/cache/#JSON-1","page":"Cache","title":"JSON","text":"","category":"section"},{"location":"man/cache/#","page":"Cache","title":"Cache","text":"The advantage of JSON is that it is human readable, and is also language-independent, so it can be generated by programs in other languages. However, it scales poorly with larger problem dimensionalities, and a large number of points, in terms of memory, saving and loading time. A truncated example of the costs stored in JSON format is given below:","category":"page"},{"location":"man/cache/#","page":"Cache","title":"Cache","text":"{\n    \"[5.0, 2.5, 0.15]\": 12.110706,\n    \"[4.0, 1.5, 0.15]\": 9.920012,\n    \"[3.79, 26.3, 0.4]\": 3.10409,\n    ...\n}","category":"page"},{"location":"man/cache/#JLD2-1","page":"Cache","title":"JLD2","text":"","category":"section"},{"location":"man/cache/#","page":"Cache","title":"Cache","text":"JLD2 is a file format used to save Julia variables with their type information. It is provided by the JLD2.jl package. The advantage of JLD2 is that stores variables with their Julia type information, and scales significantly better with larger dictionaries than JSON. It is recommended option when using with problems of large dimensionalities (more than 100 variables).","category":"page"},{"location":"man/cache/#Functions-1","page":"Cache","title":"Functions","text":"","category":"section"},{"location":"man/cache/#","page":"Cache","title":"Cache","text":"The saving and loading of the evaluated costs is provided by the function CacheLoadJSON, CacheSaveJSON, CacheLoadJLD2, and CacheSaveJLD2.","category":"page"},{"location":"man/usage/#Usage-1","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"DirectSearch.jl provides a framework for the implementation of direct search algorithms, currently focusing on the Mesh Adaptive Direct Search (MADS) family. These are derivative free, black box algorithms, meaning that no analytical knowledge of the objective function or any constraints are needed. This package provides the core MADS algorithms (LTMADS, OrthoMADS, granular variables and dynamic scaling, as well as progressive and extreme barrier constraints), and is designed to allow custom algorithms to be easily added.","category":"page"},{"location":"man/usage/#Install-1","page":"Usage","title":"Install","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"To install the package, use the following command","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"pkg> add https://github.com/ImperialCollegeLondon/DirectSearch.jl","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"And import as with any Julia package:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"using DirectSearch","category":"page"},{"location":"man/usage/#Problem-Specification-1","page":"Usage","title":"Problem Specification","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The core data structure is the DSProblem type. At a minimum it requires the dimension of the problem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(3);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The objective function, initial point, and other parameters may be specified in DSProblem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"obj(x) = x'*[2 1;1 4]*x + x'*[1;4] + 7;\np = DSProblem(2; objective=obj, initial_point=[1.0,2.0]);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Note that the objective function is assumed to take a vector of points of points as the input, and return a scalar cost. The initial point should be an array of the same dimensions of the problem, and feasible with respect to any extreme barrier constraints. See DSProblem's documentation for a full list of parameters.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Parameters can also be set after generation of the problem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(2)\nSetInitialPoint(p, [1.0,2.0])\nSetObjective(p,obj)\nSetIterationLimit(p, 500)","category":"page"},{"location":"man/usage/#Variable-Bounds-1","page":"Usage","title":"Variable Bounds","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The bounds of problem variables can be set with SetVariableBound or SetVariableBounds. These values are used to set the initial poll sizes of each variable. By default the variables are defined as unbounded.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"If a bound for a single variable is required to be defined, it can be set with SetVariableBound. i is the index of the variable, and the following numbers are the upper and lower bound of the variable respectively.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetVariableBound(p, i, 10000, 20000)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The same operation can be applied to all variables with SetVariableBounds (example for N=3):","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetVariableBounds(p, [10000, -5, -10000], [20000, 5, 10000])","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Be aware that this does not add a constraint on the variable, it only gives additional information when defining the initial poll size, which acts as the initial scaling of the variables. Constraints on variable range should be added explicitly as constraints.","category":"page"},{"location":"man/usage/#Granular-Variables-1","page":"Usage","title":"Granular Variables","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"If variables other than continuous, such as integers, are desired to be used, this can be specified through the granularity of the problem variables. The granularity is taken to be 0 for continuous variables and 1 for integers. The granularity can be any non-negative value.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"If the granularity for a single variable is required to be defined, it can be set with SetGranularity. i is the index of the variable, and the following number is the granularity.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetGranularity(p, i, 0.1)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The same operation can be applied to multiple variables by passing a collection of key => value pairs to the SetGranularity function:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetGranularity(p, Dict( 1 => 0.1, 2 => 0.2 ))","category":"page"},{"location":"man/usage/#Optimizing-1","page":"Usage","title":"Optimizing","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Run the algorithm with Optimize!.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Optimize!(p)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"This will run MADS until one of the defined stopping conditions is met. For more details on stopping conditions, and how to add a custom one see Adding Stopping Conditions.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"After the optimization is finished, detailed results are printed as in the following example:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"==================================================\nMADS Run Summary\n--------------------------------------------------\nFeasible Solution           [1.0005, 10.0]\nFeasible Cost               0.0\nInfeasible Solution         nothing\nInfeasible Cost             nothing\n\nIterations                  52\nFunction Evaluations        196\nCache hits                  13\nOptimization Status         Mesh Precision limit\n\nRuntime                     0.9472651481628418\nSearch Time                 4.499999999999997e-6\nPoll Time                   0.4502825000000001\nBlackbox Evaluation Time    0.00048089999999999917","category":"page"},{"location":"man/usage/#Type-Parameterisation-1","page":"Usage","title":"Type Parameterisation","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"By default, DSProblem is parameterised as Float64, but this can be overridden:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem{Float32}(3);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"However, this is mostly untested and will almost certainly break. It is included to allow future customisation to be less painful.","category":"page"},{"location":"man/usage/#Parallel-Blackbox-Evaluations-1","page":"Usage","title":"Parallel Blackbox Evaluations","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"If Julia was started with more than one thread using the option --threads N where N is the number of threads, then DirectSearch.jl can be configured to evaluate the objective functions in parallel using multiple threads. This can done by calling the function SetMaxEvals:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"SetMaxEvals(p)","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Note that using multiple threads is only beneficial when the function to evaluate takes a long time using a single thread (1ms or more). Otherwise, the runtime will increase due to multi-threading overheads.","category":"page"},{"location":"man/usage/#Constraints-1","page":"Usage","title":"Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Two kinds of constraints are included, progressive barrier, and extreme barrier constraints. As with the objective function, these should be specified as a Julia function that takes a vector, and returns a value. ","category":"page"},{"location":"man/usage/#Extreme-Barrier-Constraints-1","page":"Usage","title":"Extreme Barrier Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Extreme barrier constraints are constraints that cannot be violated, and their function should return boolean (true for a feasible point, false for infeasible), or a numerical value giving the constraint violation amount (≤0 for feasible, >0 for infeasible). Added with AddExtremeConstraint:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"cons(x) = x[1] > 0 #Constrains x[1] to be larger than 0\nAddExtremeConstraint(p, cons)","category":"page"},{"location":"man/usage/#Progressive-Barrier-Constraints-1","page":"Usage","title":"Progressive Barrier Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Progressive barrier constraints may be violated, transforming the optimization into a dual-objective form that attempts to decrease the amount that the constraint is violated by. Functions that implement a progressive barrier constraint should take a point input and return a numerical value that indicates the constraint violation amount (≤0 for feasible, >0 for infeasible). Added via AddProgressiveConstraint:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"cons(x) = x[1] #Constraints x[1] to be less than or equal to 0\nAddProgressiveConstraint(p, cons)","category":"page"},{"location":"man/usage/#Equality-Constraints-1","page":"Usage","title":"Equality Constraints","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The package does not care about the form of constraints (as they are treated like a black box). However in many cases, the algorithm will not be able to generate trial points that are exactly able to satisfy equality constraints. ","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Therefore, to implement extreme barrier equality constraints a tolerance should be included in the constraint function. Alternatively progressive barrier constraints can be used, but it is likely that the algorithm will not be able to generate feasible solutions, but the final point should be very close to feasible.","category":"page"},{"location":"man/usage/#Constraint-Indexes-1","page":"Usage","title":"Constraint Indexes","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The functions to add a constraint return an index that can be used to refer to the constraints for modification. When supplied with a vector of functions both constraint functions will return a vector of indexes.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Currently these indexes have no direct use. But functions to ignore constraints will be added in future.","category":"page"},{"location":"man/usage/#Collections-1","page":"Usage","title":"Collections","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Constraints are stored in data structures named 'Collections'. Each collection can contain any number of constraints of the same type. By default, extreme barrier constraints are stored in collection one, and progressive barrier constraints in collection two. In most cases, collections can be ignored.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"New collections can be created with the following functions:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"AddProgressiveCollection(p);\nAddExtremeCollection(p);","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The collection contains configuration options for the constraints within it. For example, by default the progressive barrier collection uses a square norm when summing constraint violation, this can be configured to use an alternate norm by defining a new collection. See the documentation for the individual functions for all the possible configuration options.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"As with adding individual constraints, collections return an index. This is useful for specifying a collection to add a constraint to. These indexes will also be used to refer to the collections for modification in future. ","category":"page"},{"location":"man/usage/#Method-Choice-1","page":"Usage","title":"Method Choice","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"MADS defines two stages in each iteration: search and poll. ","category":"page"},{"location":"man/usage/#Search-1","page":"Usage","title":"Search","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The search stage employs an arbitrary strategy to look for an improved point in the current mesh. This can be designed to take advantage of a known property of the objective function's structure, or be something generic, for example, a random search, or ignored. ","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"A search step returns a set of points that are then evaluated on the objective function.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The choice of search strategy is set in DSProblem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(3; search=RandomSearch(10))","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The current included search strategies are NullSearch and RandomSearch. NullSearch will perform no search stage and is the default choice. RandomSearch will select M random points on the current mesh, where M is the option given to it when instantiated.","category":"page"},{"location":"man/usage/#Poll-1","page":"Usage","title":"Poll","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"The poll step is a more rigorously defined exploration in the local space around the incumbent point.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Poll steps return a set of directions that are then evaluated with a preset distance value.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"As with the search step, it is set in DSProblem:","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"p = DSProblem(3; poll=LTMADS())\np = DSProblem(3; poll=OrthoMADS())","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Two poll types are included. The first is LTMADS, which generates a set of directions from a basis generated from a semi-random lower triangular matrix. The other is OrthoMADS, a later algorithm that generates an orthogonal set of directions. It was recently adapted to granular variables in 2019 C. Audet, S. Le Digabel, and C. Tribes, but the same name is continued to be used. By default, LTMADS is used.","category":"page"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"Both OrthoMADS and LTMADS are non-deterministic, and will therefore give different results every time they are run. For this reason, they may need several runs to achieve their best results.","category":"page"},{"location":"man/usage/#Custom-Algorithms-1","page":"Usage","title":"Custom Algorithms","text":"","category":"section"},{"location":"man/usage/#","page":"Usage","title":"Usage","text":"DirectSearch.jl is designed to make it simple to add custom search and poll stages. See Adding a Search Step and Adding a Poll Step for an overview of this.","category":"page"},{"location":"man/addpoll/#Adding-a-Poll-Step-1","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"","category":"section"},{"location":"man/addpoll/#Implementation-1","page":"Adding a Poll Step","title":"Implementation","text":"","category":"section"},{"location":"man/addpoll/#","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"A poll step can be implemented in a very similar manner to a search step. However, a poll stage should return a direction, not a discrete point. Therefore the function GenerateDirections should be overridden instead. As with the search step, this takes the problem as the first argument and the poll type as the second, and returns a vector of directions. A struct configuring a poll type must inherit the AbstractPoll type. As an example, please see the file src/LTMADS.jl.","category":"page"},{"location":"man/addpoll/#","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"Note that, for the convergence properties of MADS to hold, the poll step has several requirements, and therefore it is generally recommended to use LTMADS or OrthoMADS and modify the search stage to fit the problem.","category":"page"},{"location":"man/addpoll/#Organisation-1","page":"Adding a Poll Step","title":"Organisation","text":"","category":"section"},{"location":"man/addpoll/#","page":"Adding a Poll Step","title":"Adding a Poll Step","text":"Custom poll stages should be included in their own file.","category":"page"},{"location":"ref/public/#Public-API-1","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"These functions and types implement the API of DirectSearch.jl. ","category":"page"},{"location":"ref/public/#Problem-Configuration-1","page":"Public API","title":"Problem Configuration","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"DSProblem\nSetObjective\nSetInitialPoint\nOptimize!\nSetVariableBound\nSetVariableBounds\nSetGranularity\nSetGranularities\nSetSense\nSetMaxEvals\nSetOpportunisticEvaluation","category":"page"},{"location":"ref/public/#DirectSearch.DSProblem","page":"Public API","title":"DirectSearch.DSProblem","text":"DSProblem{T, UT}(N::Int; poll::AbstractPoll=LTMADS{T}(),\n                         search::AbstractSearch=NullSearch(),\n                         objective::Union{Function,Nothing}=nothing,\n                         initial_point::Vector=zeros(T, N),\n                         iteration_limit::Int=1000,\n                         function_evaluation_limit::Int=5000,\n                         sense::ProblemSense=Min,\n                         full_output::Bool=false,\n                         granularity::Vector=zeros(T, N),\n                         min_mesh_size::Union{T,Nothing}=nothing,\n                         min_poll_size::Union{T,Nothing}=nothing,\n                         kwargs...\n                         ) where T\n\nReturn a problem definition for an N dimensional problem using numbers of type T.\n\npoll and search specify the poll and search step algorithms to use. The default choices are LTMADS and NullSearch respectively.\n\nThe problem can contain user-defined parameters that are passed into every objective function evaluation. These parameters will be stored inside a field of type UT.\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#DirectSearch.SetObjective","page":"Public API","title":"DirectSearch.SetObjective","text":"SetObjective(p::DSProblem, obj::Function)\n\nSets the target objective function to solve. obj should take a vector and return a single cost value.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetInitialPoint","page":"Public API","title":"DirectSearch.SetInitialPoint","text":"SetInitialPoint(p::DSProblem{T}, x::Vector{T}) where T\n\nSet the initial incumbent point to x. This must be of the correct dimension. If using any extreme barrier constraints then it must also satisfy these constraints.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.Optimize!","page":"Public API","title":"DirectSearch.Optimize!","text":"Optimize!(p::DSProblem)\n\nRun the direct search algorithm on problem p.\n\np must have had its initial point and objective function set. If extreme barrier constraints have been set then the initial point must be value for those constraints.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetVariableBound","page":"Public API","title":"DirectSearch.SetVariableBound","text":"SetVariableBound(p::DSProblem{T}, index::Int, l::T, u::T) where T\n\nSet the expected bounds of the variable with index i to between lower (l) and upper (u) values. This does not create a constraint, and is only used for scaling when a variable varies with a significantly different scale to the others.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetVariableBounds","page":"Public API","title":"DirectSearch.SetVariableBounds","text":"SetVariableBounds(p::DSProblem{T}, l::Vector{T}, u::Vector{T}) where T\n\nCall SetVariableBound for each variable. The vectors l and u should contain a lower and upper bound for each variable.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetGranularity","page":"Public API","title":"DirectSearch.SetGranularity","text":"SetGranularity(p::DSProblem{T}, index::Int, granularity::T) where T\n\nSet the granularity of the variable with index i to granularity.\n\n\n\n\n\nSetGranularity(p::DSProblem{T}, granularities)\n\nSet the granularity of multiple variables. The granularities should be provided in granularities as a collection with key => value pairs, where the key is the variable index and the value is the granularity.\n\nExamples\n\njulia> p = DSProblem(3; objective=x->sum(x.^2), initial_point=[0.25, 0.1, 1.0]);\n\njulia> granularities = Dict( 1 => 0.1, 2 => 0.2, 3 => 0.3 )\nDict{Int64, Float64} with 3 entries:\n  2 => 0.2\n  3 => 0.3\n  1 => 0.1\n\njulia> SetGranularity(p, granularities)\n\nA vector can also be used to set the granularity, with granularities[index] setting the granularity for the variable at index with the granularity granularities[index].\n\njulia> p = DSProblem(3; objective=x->sum(x.^2), initial_point=[0.25, 0.1, 1.0]);\n\njulia> granularities = [0.1; 0.2; 0.3]\n3-element Vector{Float64}:\n 0.1\n 0.2\n 0.3\n\njulia> SetGranularity(p, granularities)\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetSense","page":"Public API","title":"DirectSearch.SetSense","text":"SetSense(p::DSProblem, sense::ProblemSense )\n\nSet the problem sense. Valid values for sense are DS.Min and DS.Max.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetMaxEvals","page":"Public API","title":"DirectSearch.SetMaxEvals","text":"SetMaxEvals(p::DSProblem, max::Bool=true)\n\nSet/unset parallel blackbox evaluations. The number of threads Julia was started with will be used.\n\nNote that using parallel blackbox evaluations will only result in reduced runtime for problems that have long blackbox evaluations.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetOpportunisticEvaluation","page":"Public API","title":"DirectSearch.SetOpportunisticEvaluation","text":"SetOpportunisticEvaluation(p::DSProblem; opportunistic::Bool=true)\n\nSet/unset opportunistic evaluation (enables by default).\n\nWhen using opportunistic evaluation the first allowable evaluated point with an improved cost is set as the new incumbent solution. If using progressive barrier constraints this point may be infeasible.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#Search-Stages-1","page":"Public API","title":"Search Stages","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"NullSearch\nRandomSearch","category":"page"},{"location":"ref/public/#DirectSearch.NullSearch","page":"Public API","title":"DirectSearch.NullSearch","text":"NullSearch()\n\nReturn no trial points for a search stage (ie, skips the search stage from running)\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#DirectSearch.RandomSearch","page":"Public API","title":"DirectSearch.RandomSearch","text":"RandomSearch(M::Int)\n\nReturn M randomly chosen trial points from the current mesh.\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#Poll-Stages-1","page":"Public API","title":"Poll Stages","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"LTMADS\nOrthoMADS","category":"page"},{"location":"ref/public/#DirectSearch.LTMADS","page":"Public API","title":"DirectSearch.LTMADS","text":"LTMADS()\n\nReturn an empty LTMADS object.\n\nLTMADS is a poll stage that creates a set of directions based on a semi-randomly generated lower triangular matrix. This randomness means that several runs of the algorithm may be needed to find a minimum.\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#DirectSearch.OrthoMADS","page":"Public API","title":"DirectSearch.OrthoMADS","text":"OrthoMADS()\n\nReturn an empty OrthoMADS object. N must match the dimension of the problem that this stage is being given to.\n\nOrthoMADS uses Halton sequences to generate an orthogonal basis of directiosn for the poll step. This is a deterministic process, unlike (LTMADS)[@ref].\n\n\n\n\n\n","category":"type"},{"location":"ref/public/#Constraints-1","page":"Public API","title":"Constraints","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"AddExtremeConstraint(p::DirectSearch.AbstractProblem, f::Function)\nAddExtremeConstraint(p::DirectSearch.AbstractProblem, f::Vector{Function})\nAddProgressiveConstraint(p::DirectSearch.AbstractProblem, f::Function)\nAddProgressiveConstraint(p::DirectSearch.AbstractProblem, f::Vector{Function})\nAddExtremeCollection(p::DirectSearch.AbstractProblem)\nAddProgressiveCollection(p::DirectSearch.AbstractProblem)\nDefaultExtremeRef\nDefaultProgressiveRef","category":"page"},{"location":"ref/public/#DirectSearch.AddExtremeConstraint-Tuple{DirectSearch.AbstractProblem, Function}","page":"Public API","title":"DirectSearch.AddExtremeConstraint","text":"AddExtremeConstraint(p::AbstractProblem, c::Function\n                     index::CollectionIndex=CollectionIndex(1)\n                    )::ConstraintIndex where T\n\nRegister a single function that defines an extreme barrier constraint. Return a constraint index.\n\nThe provided function should take a vector input and return a boolean or numeric value indicating if the constraint has been met or not. true or less than or equal to 0 indicates the constraint has been met. false or greater than 0 shows the constraint has been violated.\n\nThe index argument can be specified to give a collection to add the constraint to. The specified collection must exist, and must be able to accept extreme barrier constraints. If index is not specified then it is added to collection 1, the default extreme constraint collection.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddExtremeConstraint-Tuple{DirectSearch.AbstractProblem, Vector{Function}}","page":"Public API","title":"DirectSearch.AddExtremeConstraint","text":"AddExtremeConstraint(p::AbstractProblem, c::Vector{Function}; index::CollectionIndex=CollectionIndex(1))\n\nRegister a group of functions that define extreme barrier constraints. Calls AddExtremeConstraint on each function individually.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddProgressiveConstraint-Tuple{DirectSearch.AbstractProblem, Function}","page":"Public API","title":"DirectSearch.AddProgressiveConstraint","text":"AddProgressiveConstraint(p::AbstractProblem, c::Function; index::CollectionIndex=CollectionIndex(2))\n\nRegister a single function that defines a progressive barrier constraint. Return an index that refers to the constraint.\n\nThe provided function should take a vector input and return a numeric value indicating if the constraint has been met or not. Less than or equal to 0 indicates the constraint has been met. 0 shows the constraint has been violated.\n\nThe index argument can be specified to give a collection to add the constraint to. The specified collection must exist, and must be able to accept progressive barrier constraints. If index is not specified then it is added to collection 2, the default progressive barrier constraint collection.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddProgressiveConstraint-Tuple{DirectSearch.AbstractProblem, Vector{Function}}","page":"Public API","title":"DirectSearch.AddProgressiveConstraint","text":"AddProgressiveConstraint(p::AbstractProblem, c::Vector{Function})::Vector{Int}\n\nRegister a group of functions that define progressive barrier constraints. Calls AddProgressiveConstraint on each function individually.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddExtremeCollection-Tuple{DirectSearch.AbstractProblem}","page":"Public API","title":"DirectSearch.AddExtremeCollection","text":"AddExtremeCollection(p::Constraints{FT})::CollectionIndex where {FT<:AbstractFloat}\n\nInstantiate a new constraint collection for extreme constraints. Returns an index that refers to the new collection.\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.AddProgressiveCollection-Tuple{DirectSearch.AbstractProblem}","page":"Public API","title":"DirectSearch.AddProgressiveCollection","text":"AddProgressiveCollection(p::Constraints{FT}; h_max=Inf, h_max_update::Function=h_max_update,\n                         aggregator::Function=x->max(0,x)^2)::CollectionIndex where {FT<:AbstractFloat}\n\nInstantiate a new constraint collection within the problem. Returns an index that refers to this new collection.\n\nThe default constraint settings match those from Audet & Dennis 2009:\n\nh_max: Begins as infinity\n\nh_max_update: Sets h_max to the largest valid h evaluation if an iteration is improving\n\naggregator: Creates h as sum k(x) where k=max(0x)^2\n\n\n\n\n\n","category":"method"},{"location":"ref/public/#DirectSearch.DefaultExtremeRef","page":"Public API","title":"DirectSearch.DefaultExtremeRef","text":"DefaultExtremeRef\n\nThe collection index that refers to the default location of extreme barrier constraints.\n\n\n\n\n\n","category":"constant"},{"location":"ref/public/#DirectSearch.DefaultProgressiveRef","page":"Public API","title":"DirectSearch.DefaultProgressiveRef","text":"DefaultProgressiveRef\n\nThe collection index that refers to the default location of progressive barrier constraints.\n\n\n\n\n\n","category":"constant"},{"location":"ref/public/#Cache-1","page":"Public API","title":"Cache","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"CacheLoadJSON\nCacheSaveJSON\nCacheLoadJLD2\nCacheSaveJLD2","category":"page"},{"location":"ref/public/#DirectSearch.CacheLoadJSON","page":"Public API","title":"DirectSearch.CacheLoadJSON","text":"CacheLoadJSON(p::AbstractProblem{T}, path::String) where T\n\nLoad the costs from the provided JSON file to the cache. path can be a relative or absolute path and must contain the '.json' extension.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.CacheSaveJSON","page":"Public API","title":"DirectSearch.CacheSaveJSON","text":"CacheSaveJSON(p::AbstractProblem{T}, filename::String) where T\n\nSave the costs from the cache to JSON file with the name filename. Note that  the filename should be without a file extension.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.CacheLoadJLD2","page":"Public API","title":"DirectSearch.CacheLoadJLD2","text":"CacheLoadJLD2(p::AbstractProblem{T}, path::String, dataset::String=\"cache_costs\") where T\n\nLoad the costs from the provided JLD2 file and dataset to the cache. path can be a relative or absolute path and must contain the '.jld2' extension. By default, it loads from the dataset named 'cache_costs'.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.CacheSaveJLD2","page":"Public API","title":"DirectSearch.CacheSaveJLD2","text":"CacheSaveJLD2(p::AbstractProblem{T}, filename::String, dataset::String=\"cache_costs\") where T\n\nSave the costs from the cache to a JLD2 file with the name filename and to the dataset dataset. The default dataset is named 'cache_costs'. It is possible to write to multiple datasets in one file, however, datasets cannot be overwritten.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#Stopping-Conditions-1","page":"Public API","title":"Stopping Conditions","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"AddStoppingCondition\nSetIterationLimit\nBumpIterationLimit\nSetFunctionEvaluationLimit\nBumpFunctionEvaluationLimit\nSetMinimumMeshSize\nSetMinimumPollSize","category":"page"},{"location":"ref/public/#DirectSearch.AddStoppingCondition","page":"Public API","title":"DirectSearch.AddStoppingCondition","text":"AddStoppingCondition(p::DSProblem, c::T) where T <: AbstractStoppingCondition\n\nAdd the stopping condition c to the problem p.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetIterationLimit","page":"Public API","title":"DirectSearch.SetIterationLimit","text":"SetIterationLimit(p::DSProblem, i::Int)\n\nSet the maximum number of iterations to i.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.BumpIterationLimit","page":"Public API","title":"DirectSearch.BumpIterationLimit","text":"BumpIterationLimit(p::DSProblem, i::Int)\n\nIncrease the iteration limit by i.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetFunctionEvaluationLimit","page":"Public API","title":"DirectSearch.SetFunctionEvaluationLimit","text":"SetFunctionEvaluationLimit(p::DSProblem, i::Int)\n\nSet the maximum number of function evaluations to i.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.BumpFunctionEvaluationLimit","page":"Public API","title":"DirectSearch.BumpFunctionEvaluationLimit","text":"BumpFunctionEvaluationLimit(p::DSProblem, i::Int)\n\nIncrease the function evaluation limit by i.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetMinimumMeshSize","page":"Public API","title":"DirectSearch.SetMinimumMeshSize","text":"SetMinimumMeshSize(p::DSProblem{T}, i::T) where T\n\nSet the minimum mesh size for continuous variables.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.SetMinimumPollSize","page":"Public API","title":"DirectSearch.SetMinimumPollSize","text":"SetMinimumPollSize(p::DSProblem{T}, i::T) where T\n\nSet the minimum poll size for continuous variables.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#Reporting-1","page":"Public API","title":"Reporting","text":"","category":"section"},{"location":"ref/public/#","page":"Public API","title":"Public API","text":"ReportConfig\nReportStatus\nReportProblem\nBase.print","category":"page"},{"location":"ref/public/#DirectSearch.ReportConfig","page":"Public API","title":"DirectSearch.ReportConfig","text":"ReportConfig(p::DSProblem)\n\nPrint the configuration options currently used by p.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.ReportStatus","page":"Public API","title":"DirectSearch.ReportStatus","text":"ReportStatus(p::DSProblem)\n\nPrint the current non-problem-specific status information of p.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#DirectSearch.ReportProblem","page":"Public API","title":"DirectSearch.ReportProblem","text":"ReportProblem(p::DSProblem)\n\nPrint the current problem specific status information of p.\n\n\n\n\n\n","category":"function"},{"location":"ref/public/#Base.print","page":"Public API","title":"Base.print","text":"Base.print(p::DSProblem)\n\nPrint the output of ReportConfig, ReportStatus, and ReportProblem in a list.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#Internal-API-1","page":"Internal","title":"Internal API","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"These functions and types are for internal usage and should generally not be accessed during normal use of the package. This will likely be useful if implementing an extension to the package. ","category":"page"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"Fully documenting every function is currently ongoing. Please raise an issue if information is missing.","category":"page"},{"location":"ref/internal/#Core-1","page":"Internal","title":"Core","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.EvaluateInitialPoint\nDirectSearch.EvaluatePoint!\nDirectSearch.EvaluatePointSequential!\nDirectSearch.EvaluatePointParallel!\nDirectSearch.function_evaluation\nDirectSearch.function_evaluation_parallel","category":"page"},{"location":"ref/internal/#DirectSearch.EvaluateInitialPoint","page":"Internal","title":"DirectSearch.EvaluateInitialPoint","text":"EvaluateInitialPoint(p::DSProblem)\n\nEvaluate the initial point.\n\nThrows an error if the initial point is not feasible.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.EvaluatePoint!","page":"Internal","title":"DirectSearch.EvaluatePoint!","text":"EvaluatePoint!(p::DSProblem{FT}, trial_points)::IterationOutcome where {FT<:AbstractFloat}\n\nDetermine whether the set of trial points result in a dominating, improving, or unsuccesful algorithm iteration. Update the feasible and infeasible incumbent points of p.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.EvaluatePointSequential!","page":"Internal","title":"DirectSearch.EvaluatePointSequential!","text":"EvaluatePointSequential(p::DSProblem{FT}, trial_points::Vector{Vector{FT}})::IterationOutcome where {FT<:AbstractFloat}\n\nSingle-threaded evaluation of set of trial points.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.EvaluatePointParallel!","page":"Internal","title":"DirectSearch.EvaluatePointParallel!","text":"EvaluatePointParallel!(p::DSProblem{FT}, trial_points::Vector{Vector{FT}})::IterationOutcome where {FT<:AbstractFloat}\n\nMulti-threaded evaluation of set of trial points. Uses the number of threads that Julia was started with.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.function_evaluation","page":"Internal","title":"DirectSearch.function_evaluation","text":"function_evaluation(p::DSProblem{T}, trial_point::Vector{T})::(T, Bool) where T\n\nEvaluate a single trial point with the objective function of p.\n\nBy default calls the function with the trial point and returns the result. Override to provide custom evaluation behaviour.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.function_evaluation_parallel","page":"Internal","title":"DirectSearch.function_evaluation_parallel","text":"function_evaluation_parallel(p::DSProblem{T}, trial_point::Vector{T})::Tuple{T, Bool} where T\n\nEvaluate a single trial point with the objective function of p using multiple threads.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#Constraints-1","page":"Internal","title":"Constraints","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.AbstractConstraint\nDirectSearch.IterationOutcome\nDirectSearch.ConstraintOutcome\nDirectSearch.CollectionIndex\nDirectSearch.ConstraintIndex\nDirectSearch.ConstraintCollection\nDirectSearch.h_max_update\nDirectSearch.AbstractProgressiveConstraint\nDirectSearch.ProgressiveConstraint\nDirectSearch.ExtremeConstraint\nDirectSearch.Constraints\nDirectSearch.CollectionTypeCount\nDirectSearch.ConstraintUpdate!\nDirectSearch.ConstraintEvaluation\nDirectSearch.GetHmaxSum\nDirectSearch.ConstraintCollectionEvaluation(::DirectSearch.ConstraintCollection{T,DirectSearch.ProgressiveConstraint}, ::Vector{T}) where T\nDirectSearch.ConstraintCollectionEvaluation(::DirectSearch.ConstraintCollection{T,DirectSearch.ExtremeConstraint}, ::Vector{T}) where T","category":"page"},{"location":"ref/internal/#DirectSearch.IterationOutcome","page":"Internal","title":"DirectSearch.IterationOutcome","text":"@enum IterationOutcome\n\nHas values Dominating, Improving, or Unsuccessful. Corresponding to the three iteration outcomes in MADS-PB.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ConstraintOutcome","page":"Internal","title":"DirectSearch.ConstraintOutcome","text":"@enum ConstraintOutcome\n\nHas the values Feasible, WeakInfeasible, or StrongInfeasible to classify the outcome of the constraint evaluations of a single point.\n\nA Feasible point meets the requirement of all constraints with no relaxation.\n\nA WeakInfeasible outcome has at least one relaxable constraint violated but no unrelaxable constraints violated.\n\nA StrongInfeasible outcome indicates at least one unrelaxable constraint has been violated or the relaxable constraint violation is reater than hmax.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.CollectionIndex","page":"Internal","title":"DirectSearch.CollectionIndex","text":"CollectionIndex\n\nAn Int wrapper that is used for indexing constraint collections within a Constraints object.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ConstraintIndex","page":"Internal","title":"DirectSearch.ConstraintIndex","text":"CollectionIndex\n\nAn Int wrapper that is used for indexing constraints within a ConstraintCollection object.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ConstraintCollection","page":"Internal","title":"DirectSearch.ConstraintCollection","text":"ConstraintCollection{FT,C}(h_max::FT,\n                           h_max_update::Function,\n                           aggregator::Function\n                          ) where {FT<:AbstractFloat,C<:AbstractConstraint}\n\nContains multiple constraints of the same type that have the same settings applied to them.\n\nh_max is the initial hmax value. h_max_update is a function that should update h_max given an IterationOutcome value. aggregator is a function that will bring all constraint violations of a collection into a single h result.\n\nDefaults for each of these values are set in the AddProgressiveCollection and AddExtremeCollection functions.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.AbstractProgressiveConstraint","page":"Internal","title":"DirectSearch.AbstractProgressiveConstraint","text":"AbstractProgressiveConstraint <: AbstractConstraint\n\nParent type for progressive contraints.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ProgressiveConstraint","page":"Internal","title":"DirectSearch.ProgressiveConstraint","text":"ProgressiveConstraint(f::Function)\n\nCreate a progressive barrier constraint.\n\nArgument f is a function that should take a single vector argument and return a value that gives the amount the constraint function has been violated.\n\nA value greater than 0 indicates the function has been violated, 0 shows that the input lies on the constraint, and negative numbers show a feasible value.\n\nNegative numbers may be truncated to 0 without affecting the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.ExtremeConstraint","page":"Internal","title":"DirectSearch.ExtremeConstraint","text":"ExtremeConstraint(f::Function)\n\nCreate an extreme barrier constraint. Function f should take a vector argument and return true or false to indicate if the vector meets the constraint.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.Constraints","page":"Internal","title":"DirectSearch.Constraints","text":"Constraints{FT<:AbstractFloat}()\n\nCreate an object that constains multiple ConstraintCollection objects and their corresponding ConstraintCache.\n\nUpon creation Constraints is automaticvally populated with two constraint collections, an ExtremeCollection and a ProgressiveCollection.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.CollectionTypeCount","page":"Internal","title":"DirectSearch.CollectionTypeCount","text":"CollectionTypeCount(c::Constraints{T}, C::AbstractConstraint)::Int where T\n\nReturn the total number of constraints of type C that are stored in all collections.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.ConstraintEvaluation","page":"Internal","title":"DirectSearch.ConstraintEvaluation","text":"ConstraintEvaluation(constraints::Constraints{T}, p::Vector{T})::Tuple{ConstraintOutcome,T} where T\n\nEvaluate point p over all constraint collections in constraints. Returns a ConstraintOutcome indicating the result of the evaluation:\n\nFeasible: p evaluated as feasible for all constraints (extreme and progressive barrier)\n\nWeakInfeasible: p evaluated as feasible for all extreme barrier constraints, and had no progressive barrier constraint violations greater than h_max\n\nStrongInfeasible: At least one extreme barrier constraint evaluated as infeasible, or at least one progressive barrier constraint had a violation greater than h_max\n\nThe second returned value is the sum of h_max values evaluated during the constraint checks.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#Mesh-1","page":"Internal","title":"Mesh","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.AbstractMesh\nDirectSearch.MeshSetup!\nDirectSearch.MeshUpdate!\nDirectSearch.SetMeshParameters!\nDirectSearch.SetMeshSizeVector!\nDirectSearch.SetPollSizeVector!\nDirectSearch.SetRatioVector!\nDirectSearch.init_a_and_b!\nDirectSearch.get_poll_size_estimate","category":"page"},{"location":"ref/internal/#DirectSearch.AbstractMesh","page":"Internal","title":"DirectSearch.AbstractMesh","text":"abstract type AbstractMesh end\n\nParent type of any struct implementing the construction of a mesh. To maintain compatibility with other aspects of the package, the naming convention for variables within structs must be followed. These respect the notation used within Audet, Le Digabel & Tribes 2019.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.MeshSetup!","page":"Internal","title":"DirectSearch.MeshSetup!","text":"MeshSetup!(p::DSProblem)\n\nSet up the mesh with the parameters defined for problem.\n\n\n\n\n\nMeshSetup!(p::DSProblem, m::AnisotropicMesh)\n\nSet up the anisotropic mesh with the parameters defined for problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.MeshUpdate!","page":"Internal","title":"DirectSearch.MeshUpdate!","text":"MeshUpdate!(p::DSProblem, result::IterationOutcome)\n\nUpdate the mesh in p based on the outcome of the most recent iteration.\n\n\n\n\n\nMeshUpdate!(mesh::AnisotropicMesh, ::AbstractPoll, result::IterationOutcome, dir::Union{Vector,Nothing})\n\nImplements update rule from Audet, Le Digabel & Tribes 2019 adapted for progressive barrier constraints with Audet & Dennis 2009 expression 2.4.\n\ndir is the direction of success of the iteration, equal to nothing, if there is none.\n\n\n\n\n\nMeshUpdate!(m::IsotropicMesh, ::AbstractPoll, result::IterationOutcome, ::Union{Vector,Nothing})\n\nImplements update rule for the isotropic mesh m with a generic polling scheme using Audet & Dennis 2006 pg. 23, with slight modifications to handle progressive barrier constrained optimization from Audet & Dennis 2009 expression 2.4.\n\n\n\n\n\nMeshUpdate!(m::IsotropicMesh, o::OrthoMADS, result::IterationOutcome, ::Union{Vector,Nothing})\n\nImplements the OrthoMads update rules for the Isotropic mesh.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.get_poll_size_estimate","page":"Internal","title":"DirectSearch.get_poll_size_estimate","text":"get_poll_size_estimate(x⁰::T, lower_bound::Union{T,Nothing}, upper_bound::Union{T,Nothing})::T where T\n\nCalculates the initial poll size, as given in Audet, Le Digabel & Tribes 2019 expression 3.3, using the initial point and variable bounds, if specified.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#Poll-1","page":"Internal","title":"Poll","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.Poll\nDirectSearch.GeneratePollPoints\nDirectSearch.GenerateDirections(::DSProblem)\nDirectSearch.SafePointGeneration\nDirectSearch.ScaleDirection","category":"page"},{"location":"ref/internal/#DirectSearch.Poll","page":"Internal","title":"DirectSearch.Poll","text":"Poll(p::DSProblem{T})::IterationOutcome where T\n\nGenerate points and call evaluate on them.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.GeneratePollPoints","page":"Internal","title":"DirectSearch.GeneratePollPoints","text":"GeneratePollPoints(p::DSProblem{T}, ::AbstractMesh)::Vector{Vector{T}} where T\n\nGenerate a set of directions with the configured polling algorithm, then return the set of points these directions give from the incumbent points.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.GenerateDirections-Tuple{DSProblem}","page":"Internal","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::DSProblem)\n\nGenerate a set of directions with the configured polling algorithm.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.ScaleDirection","page":"Internal","title":"DirectSearch.ScaleDirection","text":"ScaleDirection(p::AnisotropicMesh, dir::Vector{T}) where T\n\nScale the direction vector dir using the scaling information in the mesh m. On Anistropic meshes, this uses the vector ρ, which is the mesh ratio.\n\n\n\n\n\nScaleDirection(m::IsotropicMesh, dir::Vector{T}) where T\n\nScale the direction vector dir using the scaling information in the mesh m. For the isotropic mesh, this operation is a nop because the mesh has no scaling applied.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#Search-1","page":"Internal","title":"Search","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.Search\nDirectSearch.GenerateSearchPoints(::DSProblem{T}) where T\nDirectSearch.GenerateSearchPoints(::DSProblem{T}, ::RandomSearch) where T\nDirectSearch.GenerateSearchPoints(::DSProblem, ::NullSearch)","category":"page"},{"location":"ref/internal/#DirectSearch.Search","page":"Internal","title":"DirectSearch.Search","text":"Search(p::DSProblem{T})::IterationOutcome  where T\n\nGenerate search points and call evaluate on them.\n\n\n\n\n\n","category":"function"},{"location":"ref/internal/#DirectSearch.GenerateSearchPoints-Union{Tuple{DSProblem{T, UT, MT, ST, PT, CT} where {UT, MT, ST, PT, CT}}, Tuple{T}} where T","page":"Internal","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem{T})::Vector{Vector{T}} where T\n\nCalls GenerateSearchPoints for the search step within p.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.GenerateSearchPoints-Union{Tuple{T}, Tuple{DSProblem{T, UT, MT, ST, PT, CT} where {UT, MT, ST, PT, CT}, RandomSearch}} where T","page":"Internal","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem{T}, ::RandomSearch)::Vector{Vector{T}} where T\n\nFinds points that are Δᵐ distance from any point in the mesh in a uniformly random direction.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.GenerateSearchPoints-Tuple{DSProblem, NullSearch}","page":"Internal","title":"DirectSearch.GenerateSearchPoints","text":"GenerateSearchPoints(p::DSProblem, ::NullSearch)\n\nSearch method that returns an empty vector.\n\nUse when no search method is desired.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#LTMADS-1","page":"Internal","title":"LTMADS","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.GenerateDirections(::DirectSearch.AbstractProblem, ::LTMADS{T}) where T\nDirectSearch.form_basis_matrix\nDirectSearch.LT_basis_generation\nDirectSearch.B′_generation\nDirectSearch.b_l_generation\nDirectSearch.L_generation\nDirectSearch.B_generation","category":"page"},{"location":"ref/internal/#DirectSearch.GenerateDirections-Union{Tuple{T}, Tuple{DirectSearch.AbstractProblem, LTMADS{T}}} where T","page":"Internal","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::AbstractProblem, DG::LTMADS{T})::Matrix{T}\n\nGenerates columns and forms a basis matrix for direction generation.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#OrthoMADS-1","page":"Internal","title":"OrthoMADS","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.GenerateDirections(::DirectSearch.AbstractProblem, ::OrthoMADS)\nDirectSearch.GenerateDirectionsOnUnitSphere\nDirectSearch.HouseholderTransform","category":"page"},{"location":"ref/internal/#DirectSearch.GenerateDirections-Tuple{DirectSearch.AbstractProblem, OrthoMADS}","page":"Internal","title":"DirectSearch.GenerateDirections","text":"GenerateDirections(p::DSProblem{T}, DG::LTMADS{T})::Vector{Vector{T}}\n\nGenerates columns and forms a basis matrix for direction generation.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#Cache-1","page":"Internal","title":"Cache","text":"","category":"section"},{"location":"ref/internal/#","page":"Internal","title":"Internal","text":"DirectSearch.AbstractCache\nDirectSearch.PointCache\nDirectSearch.CachePush(::DirectSearch.AbstractProblem{T}, ::Vector{T}, ::T) where T\nDirectSearch.CachePush(::DirectSearch.AbstractProblem)\nDirectSearch.CacheQuery(::DirectSearch.AbstractProblem, ::Vector)\nDirectSearch.CacheGet(::DirectSearch.AbstractProblem, ::Vector)\nDirectSearch.CacheRandomSample(::DirectSearch.AbstractProblem, ::Int)\nDirectSearch.CacheInitialPoint(::DirectSearch.AbstractProblem)\nDirectSearch.CacheGetRange(::DirectSearch.AbstractProblem, ::Vector)\nDirectSearch.CacheFilter(::DirectSearch.AbstractProblem, ::Vector)","category":"page"},{"location":"ref/internal/#DirectSearch.AbstractCache","page":"Internal","title":"DirectSearch.AbstractCache","text":"abstract type AbstractCache end\n\nParent type of any struct implementing the cache.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.PointCache","page":"Internal","title":"DirectSearch.PointCache","text":"PointCache{T} <: AbstractCache\n\nAn abstract cache subtype that contains a dictionary of points/costs and a vector that stores the order of incumbent points.\n\n\n\n\n\n","category":"type"},{"location":"ref/internal/#DirectSearch.CachePush-Union{Tuple{T}, Tuple{DirectSearch.AbstractProblem{T}, Vector{T}, T}} where T","page":"Internal","title":"DirectSearch.CachePush","text":"CachePush(p::AbstractProblem, x::Vector, cost)\n\nAdd point x and its cost cost to the cache of p.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CachePush-Tuple{DirectSearch.AbstractProblem}","page":"Internal","title":"DirectSearch.CachePush","text":"CachePush(p::AbstractProblem)\n\nAdd the feasible and infeasible incumbent points (assuming neither are nothing) to the cache.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheQuery-Tuple{DirectSearch.AbstractProblem, Vector{T} where T}","page":"Internal","title":"DirectSearch.CacheQuery","text":"CacheQuery(p::AbstractProblem, x::Vector)\n\nQuery the cache of p to find if it has a cost value for point x. Alias to haskey.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheGet-Tuple{DirectSearch.AbstractProblem, Vector{T} where T}","page":"Internal","title":"DirectSearch.CacheGet","text":"CacheGet(p::AbstractProblem, x::Vector)\n\nReturn the cost of point x in the cache of p. Does not check if x is in the cache, use CacheQuery to check.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheRandomSample-Tuple{DirectSearch.AbstractProblem, Int64}","page":"Internal","title":"DirectSearch.CacheRandomSample","text":"CacheRandomSample(p::AbstractProblem, n::Int)\n\nReturns a uniformly sampled collection of n points from the cache. Points can be repeated in the sample.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheInitialPoint-Tuple{DirectSearch.AbstractProblem}","page":"Internal","title":"DirectSearch.CacheInitialPoint","text":"CacheInitialPoint(p::AbstractProblem)\n\nReturn a tuple of the initial point added to the cache and its cost.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheGetRange-Tuple{DirectSearch.AbstractProblem, Vector{T} where T}","page":"Internal","title":"DirectSearch.CacheGetRange","text":"CacheGetRange(p::AbstractProblem, points::Vector)::Vector{Vector}\n\nReturn a vector of costs corresponding to the vector of points.\n\n\n\n\n\n","category":"method"},{"location":"ref/internal/#DirectSearch.CacheFilter-Tuple{DirectSearch.AbstractProblem, Vector{T} where T}","page":"Internal","title":"DirectSearch.CacheFilter","text":"CacheFilter(p::AbstractProblem{T}, points::Vector{T})::Tuple{Vector{Vector{T}},Vector{Vector{T}}} where T\n\nReturn a tuple where the first entry is the set of input points in the cache and the second is the set of input points not in the cache.\n\n\n\n\n\n","category":"method"},{"location":"man/addstoppingconditions/#Adding-Stopping-Conditions-1","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"","category":"section"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"The software runs the optimization process until one of the stopping conditions is met. There are five stopping conditions defined in the package, and the ability for custom stopping conditions to be defined.","category":"page"},{"location":"man/addstoppingconditions/#Implementation-1","page":"Adding Stopping Conditions","title":"Implementation","text":"","category":"section"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"Each stopping condition is defined as a concrete type of the abstract type AbstractStoppingCondition. Two functions are required to be defined to successfully use the stopping condition - CheckStoppingCondition and StoppingConditionStatus.","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"CheckStoppingCondition is used to check if the optimization proccess should continue. s is the instance of the concrete stopping condtion type. If the optimization process needs to stop, the function should return false, otherwise return true.","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"(CheckStoppingCondition(p::DSProblem, s::T) where T <: AbstractStoppingCondition)::Bool","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"StoppingConditionStatus defines the textual representation of the stopping condition, which is used in reporting. It takes as an argument the instance of the concrete stopping condition type and should return a string. If this function is ommited, then the stopping condition status will be represented as \"Unknown stopping condition status\".","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"(StoppingConditionStatus(::T) where T <: AbstractStoppingCondition)::String","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"When the stopping condition type and functions are defined, they can be added to the problem using the function AddStoppingCondition, which takes as the first argument the DSProblem instance, and as the second argument the stopping condition instance.","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"function AddStoppingCondition(p::DSProblem, c::T) where T <: AbstractStoppingCondition\n    push!(p.stoppingconditions, c)\nend","category":"page"},{"location":"man/addstoppingconditions/#Native-1","page":"Adding Stopping Conditions","title":"Native","text":"","category":"section"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"There are currently five stopping conditions implemented in the package:","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"Iteration Limit (IterationStoppingCondition)\nFunction Evaluation Limit (FunctionEvaluationStoppingCondition)\nMesh Precision (MeshPrecisionStoppingCondition)\nPoll Precision (PollPrecisionStoppingCondition)\nRuntime Limit (RuntimeStoppingCondition)","category":"page"},{"location":"man/addstoppingconditions/#","page":"Adding Stopping Conditions","title":"Adding Stopping Conditions","text":"The first four stopping conditions are automatically included in each problem instance, and the runtime limit can be added using AddStoppingCondition.","category":"page"},{"location":"#DirectSearch.jl-1","page":"Home","title":"DirectSearch.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DirectSearch.jl implements several algorithms in the Mesh Adaptive Direct Search family and is designed to be easily modifiable but still high performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For details on the theory of the algorithms implemented here, please see:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"MADS (and LTMADS) : C.Audet and J.E. Dennis, \"Mesh adaptive direct search algorithms for constrained optimization,\" SIAM Journal on Optimization, vol. 17, no. 1, pp. 188-217, 2007\nProgressive Barrier MADS : C.Audet and J.E. Dennis, \"A progressive barrier for derivative-free nonlinear programming,\" SIAM Journal on Optimization, vol. 20, no. 1, pp. 445-472, 2009\nOrthoMADS : M. A. Abramson, C. Audet, J. E. Dennis, and S. Le Digabel, “Orthomads: A deterministic MADS instance with orthogonal directions,” SIAM Journal on Optimization, vol. 20, no. 2,pp. 948–966, 2009\nMADS for granular variables : C.  Audet,  S.  Le  Digabel,  and  C.  Tribes,  “The  mesh  adaptive  direct  search  algorithm  forgranular and discrete variables,” SIAM Journal on Optimization, vol. 29, pp. 1164–1189, 2019","category":"page"},{"location":"man/reporting/#Reporting-1","page":"Reporting","title":"Reporting","text":"","category":"section"},{"location":"man/reporting/#Detailed-Outputting-1","page":"Reporting","title":"Detailed Outputting","text":"","category":"section"},{"location":"man/reporting/#","page":"Reporting","title":"Reporting","text":"To get a more detailed output during the optimization process, the full_output parameter may be set during the instantiation of DSProblem:","category":"page"},{"location":"man/reporting/#","page":"Reporting","title":"Reporting","text":"p = DSProblem(3; full_output=true)","category":"page"},{"location":"man/reporting/#","page":"Reporting","title":"Reporting","text":"This will result in a detailed output of each iteration to the terminal, consisting of information on the optimization parameters, incumbent feasible and infeasible points, search step, poll step, and trial point evaluations. ","category":"page"},{"location":"man/reporting/#Reports-1","page":"Reporting","title":"Reports","text":"","category":"section"},{"location":"man/reporting/#","page":"Reporting","title":"Reporting","text":"In order to generate reports about the finished optimization process the functions ReportConfig, ReportStatus, and ReportProblem can be called providing the DSProblem instance as the argument. ReportConfig details the configuration options, ReportStatus details the non-problem-specific information, while ReportProblem details the problem specific information.","category":"page"},{"location":"man/addsearch/#Adding-a-Search-Step-1","page":"Adding a Search Step","title":"Adding a Search Step","text":"","category":"section"},{"location":"man/addsearch/#Implementation-1","page":"Adding a Search Step","title":"Implementation","text":"","category":"section"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"Implementing a custom search strategy is relatively simple. It requires the implementation of a type that configures the step, and a corresponding function that implements it. The configuration type should inherit from AbstractSearch, and the function should be an implementation of the GenerateSearchPoints function that takes a DSProblem and your custom type as arguments, and returns a vector of vectors.","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"For example, a very simple random search around the current incumbent point could be defined with the struct:","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"struct RandomLocalSearch <: AbstractSearch\n    # Number of points to generate\n    N::Int \n    # Maximum distance to explore\n    d::Float64\nend","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"And then the corresponding implementation with a method of the function GenerateSearchPoints:","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"function GenerateSearchPoints(p::DSProblem{T}, s::RandomLocalSearch)::Vector{Vector{T}} where T\n    points = []\n    # Generating s.N points\n    for i in 1:s.N\n        # Generate offset vector\n        offset = zeros(p.N)\n        offset[rand(1:p.N)] = rand(-s.d:s.d)\n        # Append to points list\n        push!(points, p.x + offset)\n    end\n    # Return list\n    return points\nend","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"This can then be used as with any other search method:","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"p = DSProblem(3; poll=LTMADS(), search=RandomLocalSearch(5, 0.1));","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"(Note that this search method it is unlikely to give good results due to not adapting the direction variable d to the current mesh size.)","category":"page"},{"location":"man/addsearch/#Organisation-1","page":"Adding a Search Step","title":"Organisation","text":"","category":"section"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"Unless it is very simple (ie, fits within a single function) please implement your search method in its own file. This ensures that extra functions that are part of the method are kept in a relevant place. ","category":"page"},{"location":"man/addsearch/#","page":"Adding a Search Step","title":"Adding a Search Step","text":"If a custom search method may be useful to other people, please consider contributing it back to the package.","category":"page"}]
}
